<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>abstract-robot-dynamics: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>abstract-robot-dynamics Documentation</h1><h3 class="version">1.18.0 </h3><h2><a class="anchor" id="sec_intro">
Introduction</a></h2>
<p>We propose in the following header files abstract interfaces to define a robot with dynamics. The goal is to provide a standard within JRL developments in order to make packages dealing with humanoid robots compatible with each other.</p>
<h2><a class="anchor" id="sec_howto">
Principle</a></h2>
<div align="center">
<img src="interface.png" alt="interface.png"/>
<p><strong>The goal of the abstract interface is to provide several implementations of the same functions through standardized classes and methods. Each implementation provides derived classes of each abstract class of the interface and implements the pure virtual methods. Users using the interfaces can choose any implementations by instantiating the template allocator.</strong></p></div>
<h3><a class="anchor" id="subsec_user">
For the users</a></h3>
<p>Packages using robot dynamics are guaranted to be compatible to any package implementing the abstract interfaces, as long as they use the classes defined here.</p>
<h4><a class="anchor" id="construction">
Object constructor template class</a></h4>
<p>In object oriented programming, one cannot construct an object of an abstract class. Therefore, to create a concrete instance of an abstract class, one needs to choose which derived class (i.e. which implementation) one wants to use.</p>
<p>Let us consider the following example: a user wants to create a dynamic robot defined by the abstract interface. The user thus needs to choose which implementation of the abstract interface he is going to use. Let us assume that two implementations are available: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// Implementation 1 of dynamic robot</span>
<span class="comment">//</span>
<span class="keyword">class </span>Cimpl1DynamicRobot : <span class="keyword">public</span> <a class="code" href="a00005.html" title="Abstract class that instantiates a robot with dynamic properties.">CjrlDynamicRobot</a> {
<span class="keyword">public</span>:
  Cimpl1DynamicRobot(...);
  ...
};

<span class="comment">//</span>
<span class="comment">// Implementation 1 of joint</span>
<span class="comment">//</span>
<span class="keyword">class </span>Cimpl1JointRotation : <span class="keyword">public</span> <a class="code" href="a00009.html" title="This class represents a robot joint.">CjrlJoint</a> {
<span class="keyword">public</span>:
  Cimpl1JointRotation(...);
  ...
};

<span class="comment">//</span>
<span class="comment">// Implementation 1 of body</span>
<span class="comment">//</span>
<span class="keyword">class </span>Cimpl1Body : <span class="keyword">public</span> <a class="code" href="a00004.html">CjrlBody</a> {
<span class="keyword">public</span>:
  Cimpl1Body(...);
  ...
};


<span class="comment">//</span>
<span class="comment">// Implementation 2 of dynamic robot</span>
<span class="comment">//</span>
<span class="keyword">class </span>Cimpl2DynamicRobot : <span class="keyword">public</span> <a class="code" href="a00005.html" title="Abstract class that instantiates a robot with dynamic properties.">CjrlDynamicRobot</a> {
<span class="keyword">public</span>:
  Cimpl2DynamicRobot(...);
  ...
};

<span class="comment">//</span>
<span class="comment">// Implementation 2 of joint</span>
<span class="comment">//</span>
<span class="keyword">class </span>Cimpl2JointRotation : <span class="keyword">public</span> <a class="code" href="a00009.html" title="This class represents a robot joint.">CjrlJoint</a> {
<span class="keyword">public</span>:
  Cimpl2JointRotation(...);
  ...
};

<span class="comment">//</span>
<span class="comment">// Implementation 2 of body</span>
<span class="comment">//</span>
<span class="keyword">class </span>Cimpl2Body : <span class="keyword">public</span> <a class="code" href="a00004.html">CjrlBody</a> {
<span class="keyword">public</span>:
  Cimpl2Body(...);
  ...
};
</pre></div><p> To choose implementation 1, the user will create an object of class Cimpl1DynamicRobot: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00005.html" title="Abstract class that instantiates a robot with dynamic properties.">CjrlDynamicRobot</a>* robot = <span class="keyword">new</span> Cimpl1DynamicRobot();
</pre></div><p> This seems very simple and reasonable. However, to build the kinematic chain of the robot, the user will then create joints, bodies and for each such operation, he will construct an object of implementation 1: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00009.html" title="This class represents a robot joint.">CjrlJoint</a>* joint = <span class="keyword">new</span> Cimpl1JointRotation(inInitialPosition);
CjlrBody* body = <span class="keyword">new</span> Cimpl1Body();
</pre></div><p> We now see that several instructions are specific to implementation 1. This makes it then more difficult to choose another implementation.</p>
<p>To solve this problem, we have defined a template class CjrlRobotDynamicsObjectConstructor that takes as template parameters the name of the classes defined by the implementation. The user of the abstract interface only needs to write the following lines in his source code: </p>
<div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> CjrlRobotDynamicsObjectConstructor 
  &lt;Cimpl1dynamicRobot, Cimpl1humanoidDynamicRobot, Cimpl1jointFreeflyer, Cimpl1jointRotation, Cimpl1jointTranslation, Cimpl1body&gt; CrobotDynamicConstructor;   
</pre></div><p> This line is the only one that is specific to implementation 1 of the interface.</p>
<p>To create any object of implementation 1 of the abstract interface, the user indeed writes:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="a00005.html" title="Abstract class that instantiates a robot with dynamic properties.">CjrlDynamicRobot</a>* robot = CrobotDynamicConstructor::createDynamicRobot();

<a class="code" href="a00009.html" title="This class represents a robot joint.">CjrlJoint</a>* joint = CrobotDynamicConstructor::createJointFreeflyer(inInitialPosition);

<a class="code" href="a00009.html" title="This class represents a robot joint.">CjrlJoint</a>* joint = CrobotDynamicConstructor::createJointRotation(inInitialPosition);
</pre></div><p> where no reference of implementation 1 appears.</p>
<h4><a class="anchor" id="method">
Pure virtual methods</a></h4>
<p>By constructing objects using the template class defined in the above section and by calling only virtual methods defined in the interface classes, the user can </p>
<ul>
<li>build a dynamic model of a robot (humanoid or not) </li>
<li>make computation with this dynamic model. independently of the implementation.</li>
</ul>
<h3><a class="anchor" id="subsec_developers">
For the developers</a></h3>
<p>A developer implementing classes deriving from the abstract interface classes can share his work with the user of the above section.</p>
 
For precise specification on how to provide an implementation, <a href="abstractrobotdynamics_developing.html">Go to this page</a>
 </div>
</body>
</html>
